<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>مصحح OMR (أ ب ج د) — 20 سؤالًا</title>
<style>
  body { font-family: system-ui, "Segoe UI", Arial; margin: 0; background: #f6f7fb; color: #222; }
  header { padding: 1rem 1.25rem; background: #fff; border-bottom: 1px solid #eee; }
  main { display: grid; grid-template-columns: 1fr 380px; gap: 12px; padding: 12px; }
  .panel { background: #fff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; }
  .panel h2 { font-size: 1.05rem; margin: 0 0 8px; }
  .row { display: grid; grid-template-columns: 1fr 80px; align-items: center; gap: 8px; margin-bottom: 8px; }
  label { font-size: 0.9rem; }
  input[type="range"] { width: 100%; }
  input[type="number"], input[type="text"], select { width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; }
  button { padding: 8px 12px; border: 0; border-radius: 8px; background: #2563eb; color: #fff; cursor: pointer; }
  button.secondary { background: #6b7280; }
  #video, #canvas { width: 100%; background: #000; border-radius: 10px; }
  #overlay { position: absolute; inset: 0; pointer-events: none; }
  .grid { font-size: 0.85rem; margin-top: 8px; }
  .grid table { width: 100%; border-collapse: collapse; }
  .grid th, .grid td { border-bottom: 1px solid #eee; padding: 4px 6px; text-align: center; }
  .ok { color: #0f766e; font-weight: 600; }
  .bad { color: #dc2626; font-weight: 600; }
  .hint { color: #64748b; font-size: 0.85rem; }
</style>
</head>
<body>
<header>
  <h1>مصحح نموذج OMR — 20 سؤالًا (أ، ب، ج، د)</h1>
  <p class="hint">وجّه النموذج أمام الكاميرا، التقط الصورة، ثم عدّل الشبكة حتى تتطابق الفقاعات تمامًا.</p>
</header>

<main>
  <section class="panel">
    <h2>الكاميرا والمعالجة</h2>
    <video id="video" playsinline autoplay muted></video>
    <div style="margin-top:8px; display:flex; gap:8px;">
      <button id="initCam">تشغيل الكاميرا</button>
      <button id="capture" class="secondary">التقاط</button>
      <button id="analyze">تحليل</button>
      <button id="exportCsv" class="secondary">تصدير CSV</button>
    </div>
    <canvas id="canvas" width="1280" height="960" style="margin-top:8px;"></canvas>

    <div class="grid" id="results"></div>
  </section>

  <aside class="panel">
    <h2>المعايرة</h2>
    <div class="row"><label>الدوران (°)</label><input type="range" id="rot" min="-10" max="10" step="0.1" value="0"></div>
    <div class="row"><label>العتبة (0–255)</label><input type="range" id="thresh" min="60" max="220" step="1" value="140"></div>
    <div class="row"><label>نصف قطر الفقاعة (px)</label><input type="range" id="radius" min="10" max="40" step="1" value="18"></div>

    <h2>الهندسة العامة</h2>
    <div class="row"><label>إزاحة X (px)</label><input type="range" id="offsetX" min="-200" max="200" step="1" value="0"></div>
    <div class="row"><label>إزاحة Y (px)</label><input type="range" id="offsetY" min="-200" max="200" step="1" value="0"></div>
    <div class="row"><label>المسافة بين الصفوف (px)</label><input type="range" id="rowGap" min="30" max="80" step="1" value="44"></div>
    <div class="row"><label>المسافة بين الفقاعات (px)</label><input type="range" id="bubbleGap" min="40" max="120" step="1" value="80"></div>

    <h2>أماكن الأعمدة</h2>
    <div class="row"><label>مركز عمود اليمين X</label><input type="number" id="colRightX" value="940"></div>
    <div class="row"><label>مركز عمود اليسار X</label><input type="number" id="colLeftX" value="360"></div>
    <div class="row"><label>Y أول صف (عمود اليمين)</label><input type="number" id="startYRight" value="160"></div>
    <div class="row"><label>Y أول صف (عمود اليسار)</label><input type="number" id="startYLeft" value="160"></div>

    <h2>مفتاح الإجابة الديناميكي</h2>
    <div class="row"><label>إدخال سريع (مفصول بفواصل)</label><input type="text" id="keyCsv" placeholder="أ,ب,ج,د,أ,..." /></div>
    <div style="display:grid; grid-template-columns: repeat(2, 1fr); gap:8px; margin-top:8px;" id="keyGrid"></div>
    <div style="margin-top:8px; display:flex; gap:8px;">
      <button id="applyKey" class="secondary">تطبيق الإدخال سريعًا</button>
      <button id="resetKey" class="secondary">إعادة ضبط المفتاح</button>
    </div>
  </aside>
</main>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const resultsDiv = document.getElementById('results');

const controls = {
  rot: document.getElementById('rot'),
  thresh: document.getElementById('thresh'),
  radius: document.getElementById('radius'),
  offsetX: document.getElementById('offsetX'),
  offsetY: document.getElementById('offsetY'),
  rowGap: document.getElementById('rowGap'),
  bubbleGap: document.getElementById('bubbleGap'),
  colRightX: document.getElementById('colRightX'),
  colLeftX: document.getElementById('colLeftX'),
  startYRight: document.getElementById('startYRight'),
  startYLeft: document.getElementById('startYLeft'),
};

const initCamBtn = document.getElementById('initCam');
const captureBtn = document.getElementById('capture');
const analyzeBtn = document.getElementById('analyze');
const exportCsvBtn = document.getElementById('exportCsv');

const keyGrid = document.getElementById('keyGrid');
const keyCsv = document.getElementById('keyCsv');
const applyKeyBtn = document.getElementById('applyKey');
const resetKeyBtn = document.getElementById('resetKey');

const OPTIONS_RTL = ['أ','ب','ج','د']; // من اليمين لليسار
let answerKey = new Array(20).fill(null);

// بناء واجهة إدخال المفتاح
function buildKeyGrid() {
  keyGrid.innerHTML = '';
  for (let i = 0; i < 20; i++) {
    const wrap = document.createElement('div');
    const label = document.createElement('label');
    label.textContent = `س${i+1}`;
    const sel = document.createElement('select');
    sel.innerHTML = `<option value="">—</option>` + OPTIONS_RTL.map(o=>`<option>${o}</option>`).join('');
    sel.value = answerKey[i] ?? '';
    sel.onchange = () => answerKey[i] = sel.value || null;
    wrap.appendChild(label);
    wrap.appendChild(sel);
    keyGrid.appendChild(wrap);
  }
}

// تطبيق إدخال CSV للمفتاح
applyKeyBtn.onclick = () => {
  const parts = keyCsv.value.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean);
  for (let i=0; i<Math.min(parts.length, 20); i++) {
    const val = parts[i];
    answerKey[i] = OPTIONS_RTL.includes(val) ? val : null;
  }
  buildKeyGrid();
};
resetKeyBtn.onclick = () => {
  answerKey = new Array(20).fill(null);
  keyCsv.value = '';
  buildKeyGrid();
};

// تشغيل الكاميرا
initCamBtn.onclick = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
  video.srcObject = stream;
};

// التقاط إطار إلى اللوحة
captureBtn.onclick = () => {
  const w = canvas.width, h = canvas.height;
  // نملأ خلفية
  ctx.save();
  ctx.clearRect(0,0,w,h);
  // رسم الفيديو مع تدوير بسيط
  const angle = (+controls.rot.value) * Math.PI / 180;
  ctx.translate(w/2, h/2);
  ctx.rotate(angle);
  const scale = 1.0;
  const vw = video.videoWidth || 1280;
  const vh = video.videoHeight || 720;
  const s = Math.min(w/vw, h/vh) * scale;
  ctx.drawImage(video, -vw*s/2, -vh*s/2, vw*s, vh*s);
  ctx.restore();
  // رسم شبكة إرشادية
  drawGuide();
};

// رسم الشبكة الإرشادية فوق اللوحة
function drawGuide() {
  const w = canvas.width, h = canvas.height;
  const r = +controls.radius.value;
  const rowGap = +controls.rowGap.value;
  const bubbleGap = +controls.bubbleGap.value;
  const offX = +controls.offsetX.value;
  const offY = +controls.offsetY.value;
  const colRightX = +controls.colRightX.value + offX;
  const colLeftX  = +controls.colLeftX.value  + offX;
  const startYRight = +controls.startYRight.value + offY;
  const startYLeft  = +controls.startYLeft.value  + offY;

  ctx.save();
  ctx.globalAlpha = 0.65;
  ctx.lineWidth = 1.2;

  // عمود اليمين: أسئلة 1–10
  for (let i=0; i<10; i++) {
    const cy = startYRight + i*rowGap;
    for (let k=0; k<4; k++) {
      const cx = colRightX - k*bubbleGap; // من اليمين لليسار: أ ب ج د
      ctx.strokeStyle = '#10b981';
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
      // تسمية صغيرة
      ctx.fillStyle = '#0ea5e9';
      ctx.font = '12px Segoe UI';
      ctx.fillText(OPTIONS_RTL[k], cx-4, cy- (r+6));
    }
    // رقم السؤال
    ctx.fillStyle = '#111827';
    ctx.font = '12px Segoe UI';
    ctx.fillText(`${i+1}`, colRightX + 5, cy+4);
  }

  // عمود اليسار: أسئلة 11–20
  for (let i=0; i<10; i++) {
    const cy = startYLeft + i*rowGap;
    for (let k=0; k<4; k++) {
      const cx = colLeftX - k*bubbleGap;
      ctx.strokeStyle = '#f59e0b';
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle = '#0ea5e9';
      ctx.font = '12px Segoe UI';
      ctx.fillText(OPTIONS_RTL[k], cx-4, cy- (r+6));
    }
    ctx.fillStyle = '#111827';
    ctx.font = '12px Segoe UI';
    ctx.fillText(`${i+11}`, colLeftX + 5, cy+4);
  }
  ctx.restore();
}

// تحليل الإظلام داخل كل فقاعة
analyzeBtn.onclick = () => {
  const data = readAnswers();
  renderResults(data);
};

// قراءة الإجابات المظللة
function readAnswers() {
  const r = +controls.radius.value;
  const rowGap = +controls.rowGap.value;
  const bubbleGap = +controls.bubbleGap.value;
  const offX = +controls.offsetX.value;
  const offY = +controls.offsetY.value;
  const colRightX = +controls.colRightX.value + offX;
  const colLeftX  = +controls.colLeftX.value  + offX;
  const startYRight = +controls.startYRight.value + offY;
  const startYLeft  = +controls.startYLeft.value  + offY;
  const threshold = +controls.thresh.value;

  const res = [];
  // 1–10
  for (let i=0; i<10; i++) {
    const cy = startYRight + i*rowGap;
    const bubbles = [];
    for (let k=0; k<4; k++) {
      const cx = colRightX - k*bubbleGap;
      const darkness = sampleCircleDarkness(cx, cy, r);
      bubbles.push({ option: OPTIONS_RTL[k], darkness });
    }
    const picked = decidePick(bubbles, threshold);
    res.push({ q: i+1, bubbles, pick: picked });
  }
  // 11–20
  for (let i=0; i<10; i++) {
    const cy = startYLeft + i*rowGap;
    const bubbles = [];
    for (let k=0; k<4; k++) {
      const cx = colLeftX - k*bubbleGap;
      const darkness = sampleCircleDarkness(cx, cy, r);
      bubbles.push({ option: OPTIONS_RTL[k], darkness });
    }
    const picked = decidePick(bubbles, threshold);
    res.push({ q: i+11, bubbles, pick: picked });
  }
  return res;
}

// أخذ متوسط الإظلام داخل دائرة
function sampleCircleDarkness(cx, cy, r) {
  const x0 = Math.max(0, Math.floor(cx - r));
  const y0 = Math.max(0, Math.floor(cy - r));
  const x1 = Math.min(canvas.width-1, Math.floor(cx + r));
  const y1 = Math.min(canvas.height-1, Math.floor(cy + r));
  const img = ctx.getImageData(x0, y0, x1-x0+1, y1-y0+1);
  const { data, width, height } = img;
  let sum = 0, count = 0;
  const r2 = r*r;
  for (let y=0; y<height; y++) {
    for (let x=0; x<width; x++) {
      const dx = x - (cx - x0);
      const dy = y - (cy - y0);
      if (dx*dx + dy*dy <= r2) {
        const idx = (y*width + x) * 4;
        // تحويل إلى رمادي سريع
        const R = data[idx], G = data[idx+1], B = data[idx+2];
        const gray = (R*0.2126 + G*0.7152 + B*0.0722); // luminance
        sum += (255 - gray); // إظلام
        count++;
      }
    }
  }
  return count ? (sum / count) : 0;
}

// اختيار الفقاعة المظللة
function decidePick(bubbles, threshold) {
  // قاعدة: أي فقاعة يتجاوز إظلامها العتبة تعتبر مظللة.
  const marked = bubbles.filter(b => b.darkness >= threshold);
  if (marked.length === 1) return marked[0].option;
  // إن تعددت، نختار الأشد إظلامًا ونضع ملاحظة
  if (marked.length > 1) {
    marked.sort((a,b)=>b.darkness - a.darkness);
    return marked[0].option + ' (تداخل)';
  }
  // لا شيء مظلل بوضوح: نختار الأشد إظلامًا إن كان مقاربًا للعتبة
  const maxB = bubbles.slice().sort((a,b)=>b.darkness - a.darkness)[0];
  if (maxB.darkness >= threshold * 0.85) return maxB.option + ' (ضعيف)';
  return null;
}

// عرض النتائج وجدول التصحيح
function renderResults(data) {
  // حساب الدرجة
  let correct = 0;
  const rows = data.map(row => {
    const key = answerKey[row.q - 1];
    const isCorrect = key && row.pick && row.pick.startsWith(key);
    if (isCorrect) correct++;
    const bulbs = row.bubbles.map(b => `${b.option}:${b.darkness.toFixed(0)}`).join(' | ');
    return `<tr>
      <td>${row.q}</td>
      <td>${row.pick ?? '—'}</td>
      <td>${key ?? '—'}</td>
      <td class="${isCorrect ? 'ok' : 'bad'}">${isCorrect ? 'صح' : 'خطأ'}</td>
      <td>${bulbs}</td>
    </tr>`;
  }).join('');

  resultsDiv.innerHTML = `
    <h2>النتائج</h2>
    <p><strong>الدرجة:</strong> ${correct} / 20</p>
    <table>
      <thead><tr>
        <th>سؤال</th><th>إجابة مكتشفة</th><th>الإجابة النموذجية</th><th>نتيجة</th><th>قياسات الإظلام</th>
      </tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

// تصدير CSV
exportCsvBtn.onclick = () => {
  const data = readAnswers();
  const lines = ['Question,Detected,Key,Correct,Dark_A,Dark_B,Dark_C,Dark_D'];
  for (const row of data) {
    const key = answerKey[row.q - 1] ?? '';
    const det = row.pick ?? '';
    const isCorrect = key && det && det.startsWith(key) ? 'TRUE' : 'FALSE';
    const darks = OPTIONS_RTL.map(opt => {
      const b = row.bubbles.find(bb => bb.option === opt);
      return b ? Math.round(b.darkness) : '';
    }).join(',');
    lines.push([row.q, det, key, isCorrect, darks].join(','));
  }
  const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'omr_results.csv'; a.click();
  URL.revokeObjectURL(url);
};

// إعادة بناء واجهة المفتاح عند التحميل
buildKeyGrid();

// تحديث الشبكة عند تغيير أي منزلق
Object.values(controls).forEach(el => el.addEventListener('input', drawGuide));
</script>
</body>
</html>